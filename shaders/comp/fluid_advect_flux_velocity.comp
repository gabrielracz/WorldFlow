#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_atomic_float : enable
#include "../common/grid.comp"
#include "../common/utils.comp"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer FluidInfo {
	FluidGridInfo gridInfo;
};

layout(std430, binding = 1) buffer FluidGrid {
	FluidGridCell grid[];
};

layout(push_constant) uniform PushConstants {
	float elapsed;
	float dt;
	uint redBlack;
} pc;
vec3 traceVelocityField(vec3 pos, vec3 velocity, float dt)
{
    // TODO: more sophisticated path trace?
    return pos + (velocity * -dt);
}

vec3 sampleVelocity(uvec3 center, ivec3 offset)
{
	uvec3 cell = center + offset;
	bvec3 ge = greaterThanEqual(cell, uvec3(0));
	bvec3 le = lessThan(cell, gridInfo.resolution);
	bool occ = grid[getGridIndex(cell, gridInfo.resolution)].occupied > 0;
	bool valid = all(ge) && all(le) && !occ;
	// if(!valid) {return grid[getGridIndex(center, gridInfo.resolution)].velocity * vec3(ge) * vec3(le);}
	if(!valid) {return vec3(0.0);}
	return grid[getGridIndex(cell, gridInfo.resolution)].velocity;

}

void main()
{
	uint index = getGridIndex(gl_GlobalInvocationID, gridInfo.resolution);
	FluidGridCell cell = grid[index];
	// center grid cell position
	vec3 pos = vec3(gl_GlobalInvocationID) + vec3(0.5, 0.5, 0.5);

	const vec3 l = sampleVelocity(center, ivec3(-1, 0, 0));
	const vec3 r = sampleVelocity(center, ivec3(1, 0, 0));
	const vec3 u = sampleVelocity(center, ivec3(0, 1, 0));
	const vec3 d = sampleVelocity(center, ivec3(0, -1, 0));
	const vec3 f = sampleVelocity(center, ivec3(0, 0, 1));
	const vec3 b = sampleVelocity(center, ivec3(0, 0, -1));
	const vec3 oldVel = cell.velocity;

    float dx = gridInfo.resolution.x;
    vec3 flux = vec3(0);
    
    // X-direction flux
    flux.x = (v_right.x * v_right.x - v_left.x * v_left.x) / (2.0 * dx);
    
    // Y-direction flux
    flux.y = (v_up.y * v_up.y - v_down.y * v_down.y) / (2.0 * dx);
    
    // Z-direction flux
    flux.z = (v_forward.z * v_forward.z - v_back.z * v_back.z) / (2.0 * dx);

    vec3 newVel = oldVel - flux * pc.dt;

}
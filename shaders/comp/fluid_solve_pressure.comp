#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_atomic_float : enable
#include "../common/grid.comp"
#include "../common/utils.comp"

layout(local_size_x = GRID_LOCAL_SIZE_X, local_size_y = GRID_LOCAL_SIZE_Y, local_size_z = GRID_LOCAL_SIZE_Z) in;

layout(std430, binding = 0) buffer WorldFlowGridBuffer {
	WorldFlowGrid wfGrid;
};

layout(push_constant) uniform PushConstants {
	float elapsed;
	float dt;
	uint redBlack;
    uint subgridLevel;
} pc;

#define BLOCK_SIZE GRID_LOCAL_SIZE_X
#define CACHE_SIZE BLOCK_SIZE+2
shared float sharedPressure[CACHE_SIZE][CACHE_SIZE][CACHE_SIZE];

float samplePressure(WorldFlowSubGrid grid, uvec3 center, ivec3 offset)
{
	ivec3 cell = ivec3(center) + offset;
	bvec3 ge = greaterThanEqual(cell, ivec3(0));
	bvec3 le = lessThan(cell, ivec3(grid.resolution.xyz));
	bool valid = all(ge) && all(le);
	if(!valid) {return grid.pressureBuffer.data[getGridIndex(center, grid.resolution)];}
	if(!valid) {return 0.0;}

	bool occ = (grid.flagsBuffer.data[getGridIndex(cell, grid.resolution)] & FLAG_OCCUPIED) > 0;
	if(occ) {return 0.0;}

	return grid.pressureBuffer.data[getGridIndex(cell, grid.resolution)];
}

void loadSharedCache(uint gridIndex, ivec3 gridPos, ivec3 localPos, ivec3 coarseGridPos) {
    // load current cell's density into cache
	WorldFlowSubGrid grid =  wfGrid.subgrids[pc.subgridLevel].ref;
    sharedPressure[localPos.z+1][localPos.y+1][localPos.x+1] = grid.pressureBuffer.data[gridIndex];
    
	// load halo boundary cells
    for(int d = 0; d < 3; d++) {
        bool loEdge = localPos[d] == 0;
        bool hiEdge = localPos[d] == BLOCK_SIZE-1;
        ivec3 offset = ivec3(0);
        offset[d] = loEdge ? -1 : 1;
        if(loEdge || hiEdge) {
            ivec3 samplePos = gridPos + offset;
            ivec3 cachePos = localPos + (ivec3(1) + offset);
            ivec3 coarseGridSamplePos = coarseGridPos + offset;
            sharedPressure[cachePos.z][cachePos.y][cachePos.x] = pressureBoundary(samplePos, coarseGridSamplePos, wfGrid, pc.subgridLevel);
        }
    }
    barrier();
    memoryBarrierShared();
}




void main()
{
    if(!isWorkgroupActive(wfGrid, pc.subgridLevel, gl_WorkGroupID, gl_NumWorkGroups)) {
        return;
    }

    WorldFlowSubGrid grid = wfGrid.subgrids[pc.subgridLevel].ref;
    uvec3 localPos = gl_LocalInvocationID;
    uvec3 gridPos = getGridPos(wfGrid, pc.subgridLevel, gl_GlobalInvocationID, gl_LocalInvocationID, gl_WorkGroupID, gl_NumWorkGroups);
    uint gridIndex = getGridIndex(gridPos, grid.resolution);
    uvec3 coarseGridPos = getCoarseGridPos(gridPos, wfGrid, pc.subgridLevel);
    loadSharedCache(gridIndex, ivec3(gridPos), ivec3(localPos), ivec3(coarseGridPos));


	if(!isRedBlackActive(gridPos, pc.redBlack)){
		return;
	}

	float coarsePressure = 0.0;
	if(pc.subgridLevel > 0) {
		WorldFlowSubGrid coarseGrid = wfGrid.subgrids[pc.subgridLevel-1].ref;
		uint coarseIndex = getCoarseGridIndex(gridPos, wfGrid, pc.subgridLevel);
		// coarsePressure = coarseGrid.pressureBuffer.data[coarseIndex];
	}

	const float r = samplePressure(grid, gridPos, ivec3(1, 0, 0));
	const float l = samplePressure(grid, gridPos, ivec3(-1, 0, 0));
	const float u = samplePressure(grid, gridPos, ivec3(0, 1, 0));
	const float d = samplePressure(grid, gridPos, ivec3(0, -1, 0));
	const float f = samplePressure(grid, gridPos, ivec3(0, 0, 1));
	const float b = samplePressure(grid, gridPos, ivec3(0, 0, -1));

	const float oldPres = grid.pressureBuffer.data[gridIndex];
    const float newPres = (grid.divergenceBuffer.data[gridIndex] + r + l + u + d + f + b) / 6.0 + coarsePressure;

	// SOR
	const float result = SOR(oldPres, newPres, avg3(grid.resolution.xyx));
	// const float result = newPres;

    // guarded by red-black
    grid.pressureBuffer.data[gridIndex] = result;
	// atomicExchange(grid.pressureBuffer.data[index], result);
}
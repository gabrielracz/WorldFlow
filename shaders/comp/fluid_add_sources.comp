#version 460
#extension GL_GOOGLE_include_directive : enable
#include "../common/grid.comp"
#include "../common/utils.comp"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer FluidInfo {
	FluidGridInfo gridInfo;
};

layout(std430, binding = 1) buffer FluidGrid {
	FluidGridCell grid[];
};

layout(push_constant) uniform PushConstants {
	float elapsed;
	float dt;
	uint redBlack;
} pc;

float manhattanDistance(vec3 p1, vec3 p2) {
    return abs(p1.x - p2.x) + abs(p1.y - p2.y) + abs(p1.z + p2.z);
}

void main()
{
    uvec3 pos = gl_GlobalInvocationID;
    if (!isWithinGridBounds(pos, gridInfo.resolution)) {
        return;
    }

	const float cellSize = 1.0 / gridInfo.resolution.x;
    uint index = getGridIndex(pos, gridInfo.resolution);
    // float radius = gridInfo.resolution.x / 2;
    float radius = gridInfo.resolution.x / 5;
    uvec3 gridCenter = gridInfo.resolution / 2;
	gridCenter.x = 0;
    if(distance(pos, gridCenter) < radius) {
		// float d = (1 + cnoise(vec3(pos * cellSize * 5.2) + vec3(pc.elapsed * 0.5)))/2.0;
		// if(d > 0.6) {
		if(pc.redBlack == 1) {
			grid[index].velocity += vec3(10.0, 00.0, 00.0);
			grid[index].density += 0.0025;
		}
        // grid[index].density = cnoise(vec3(pos * cellSize * 5.2) + vec3(pc.elapsed * 0.5)) * 10.0;
        // grid[index].density = 0.2;

		// if(pc.redBlack == 1)
		// 	grid[index].velocity += vec3(40.0, 0.0, 0.0);
    }

    if(pos.x < gridInfo.resolution.x / 8 && pos.y > gridCenter.y - 20 && pos.y < gridCenter.y + 20
	   && pos.z > gridInfo.resolution.z - 20 && pos.z < gridInfo.resolution.z + 20) {
		// float v = (1 + cnoise(vec3(pos * cellSize * 3.2) + vec3(pc.elapsed * 0.2)))/2.0 * 100.0;
        // grid[index].velocity += vec3(v, 0.0, 0.0);
		if(pc.redBlack == 1) {
			// grid[index].velocity += vec3(40.0, 0.0, 0.0);
			// grid[index].density += 0.1;
		}
		// if(pc.redBlack == 1)
		// 	grid[index].density = 0.2;
    }
}
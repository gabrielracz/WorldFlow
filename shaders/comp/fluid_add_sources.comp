#version 460
#extension GL_GOOGLE_include_directive : enable
// #extension GL_EXT_debug_printf: enable
#include "../common/grid.comp"
#include "../common/utils.comp"

layout(local_size_x = GRID_LOCAL_SIZE_X, local_size_y = GRID_LOCAL_SIZE_Y, local_size_z = GRID_LOCAL_SIZE_Z) in;

layout(std430, binding = 0) buffer WorldFlowGridBuffer {
	WorldFlowGrid wfGrid;
};

layout(push_constant) uniform PushConstants {
	vec4 sourcePosition;
	vec4 velocity;
	vec4 objectPosition;
	float elapsed;
	float dt;
	float sourceRadius;
	int addVelocity;
	int addDensity;
    float density;
	uint objectType;
	float objectRadius;
	float decayRate;
	int clear;
    uint subgridLevel;
} pc;

float manhattanDistance(vec3 p1, vec3 p2) {
    return abs(p1.x - p2.x) + abs(p1.y - p2.y) + abs(p1.z + p2.z);
}

void main()
{
    if(!isWorkgroupActive(wfGrid, pc.subgridLevel, gl_WorkGroupID, gl_NumWorkGroups)) {
        return;
    }

    WorldFlowSubGrid grid = wfGrid.subgrids[pc.subgridLevel].ref;
    // TODO: translate these pos and input parameters to worldspace
    uvec3 gridPos = getGridPos(wfGrid, pc.subgridLevel, gl_GlobalInvocationID, gl_LocalInvocationID, gl_WorkGroupID, gl_NumWorkGroups);
    vec3 worldPos = gridToWorld(gridPos, grid);
    if (!isWithinGridBounds(gridPos, grid.resolution)) {
        return;
    }

    uint index = getGridIndex(gridPos, grid.resolution);

    // grid.flagsBuffer.data[index] &= ~FLAG_TRANSIENTS;
    grid.flagsBuffer.data[index] = 0;
    grid.pressureBuffer.data[index] = 0.0;
    grid.debugBuffer.data[index] = vec4(0.0);

	if(pc.clear > 0) {
        clearGridCell(grid, index);
		return;
	}

    if(distance(gridPos, pc.sourcePosition.xyz) < pc.sourceRadius) {
        if(pc.addDensity > 0) {
            grid.densityBuffer.data[index] += pc.density * pc.dt;
			grid.flagsBuffer.data[index] |= FLAG_SOURCE;
        }

        if(pc.addVelocity > 0) {
            grid.velocityBuffer.data[index] += pc.velocity * pc.dt;
			grid.flagsBuffer.data[index] |= FLAG_SOURCE;
        }
    }


    bool setActive = false;
    float objDist = distance(worldPos, pc.objectPosition.xyz);
    if( objDist < (pc.objectRadius+grid.cellSize) && pc.objectType > 0) {
        grid.flagsBuffer.data[index] |= FLAG_OCCUPIED;
        setActive = true;
    }

    // if(pc.subgridLevel < wfGrid.subgridCount-1 && distance(gridPos, pc.objectPosition.xyz) < (pc.objectRadius*2.0)) {
    //     grid.flagsBuffer.data[index] |= FLAG_ACTIVE;
    // }

    // if(pc.subgridLevel == 0) {
    //     grid.flagsBuffer.data[index] |= FLAG_ACTIVE;
    // }

    if(pc.subgridLevel < wfGrid.subgridCount-1 && grid.densityBuffer.data[index] > 0.05) {
        setActive = true;
    }

    if(setActive) {
        if(pc.subgridLevel == 0) {
            grid.flagsBuffer.data[index] |= FLAG_ACTIVE;
        }
        else {
            WorldFlowSubGrid cg = wfGrid.subgrids[pc.subgridLevel-1].ref;
            uvec3 coarseGridPos = getCoarseGridPos(gridPos, wfGrid, pc.subgridLevel);
            uint coarseIndex = getGridIndex(coarseGridPos, cg.resolution);
            if((cg.flagsBuffer.data[coarseIndex] & FLAG_ACTIVE) > 0) {
                grid.flagsBuffer.data[index] |= FLAG_ACTIVE;
            }
        }
    }

    if(pc.subgridLevel > 1) {
        grid.debugBuffer.data[index] = vec4(0.75);
    }

    grid.densityBuffer.data[index] *= exp(-pc.decayRate * pc.dt);
}
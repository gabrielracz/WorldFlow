#version 460
#extension GL_EXT_scalar_block_layout : enable
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;



const uint MaxKernelSize = 64*64;
struct Kernel
{
    uvec4 size;
    float weights[MaxKernelSize];
};

layout(binding = 0, set = 0, rgba32f) uniform readonly image2D srcImg;
layout(binding = 1, set = 0, rgba32f) uniform writeonly image2D dstImg;
layout(std430, binding = 2, set = 0) uniform readonly KernelUniform {
    Kernel kernel;
};

layout(push_constant) uniform PushConstants {
    vec4 colorMask;
    float kernelScale;
    int activationFn;
    float activationParam;
} pc;

float activation(float x) {
    switch(pc.activationFn) {
        case 0:
            return x;
        case 1:
            return abs(x);
        case 2:
            return pow(x, 2);
        case 3:
            return max(0.0, x); // ReLU
        case 4:
            return x * (1.0 / (1.0 + exp(-x))); // Swish
        case 5:
            return tanh(x);
        case 6:
            // return sqrt(x*x + pc.activationParam) - sqrt(pc.activationParam); // SoftPlus
            return 1.0 - max(0.0, 1.0 - abs(x)); // Tent
        // case 7:
        //     return max(0.0, 1.0 - abs(x)); // Tent
    }
    return x;
}

vec4 applyKernel(ivec2 index, Kernel k)
{
    vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
    ivec2 h = ivec2(k.size.xy / 2);
    for(int y = 0; y < k.size.y; y++) {
        for(int x = 0; x < k.size.x; x++) {
            vec4 src = imageLoad(srcImg, index + ivec2(x, y) - h);
            result += vec4(
                src.r * k.weights[y * k.size.x + x],
                src.g * k.weights[y * k.size.x + x],
                src.b * k.weights[y * k.size.x + x],
                0.0
            ) * pc.kernelScale;
        }
    }
    result = vec4(activation(result.r), activation(result.g), activation(result.b), 1.0);
    return result;
}

void main()
{
    ivec2 index = ivec2(gl_GlobalInvocationID.xy);
    ivec2 border = ivec2(kernel.size.xy)/2;
    if(any(lessThanEqual(index, border)) ||
       any(greaterThanEqual(index, imageSize(srcImg) - border + 1))) {
        imageStore(dstImg, index, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }
    vec4 result = applyKernel(index, kernel);
    result = clamp(result, vec4(0.0, 0.0, 0.0, 1.0), vec4(1.0));
    imageStore(dstImg, index, result);
}
struct FluidGridCell
{
	vec4 velocity;
	float density;
    float pressure;
    float divergence;
    uint flags;
    vec4 debug;
};

struct FluidGridInfo
{
	uvec4 resolution;
	vec4 position;
	float cellSize;
};

uint FLAG_OCCUPIED = 0x00000001;
uint FLAG_SOURCE   = 0x00000002;


FluidGridCell zeroGridCell() {
	return FluidGridCell(vec4(0.0), 0.0, 0.0, 0.0, 0, vec4(0.0));
}

bool checkFlag(uint flags, uint mask)
{
	return (flags & mask) > 0;
}

bool isWithinGridBounds(uvec3 p, uvec4 gridResolution)
{
    return p.x < gridResolution.x &&
           p.y < gridResolution.y && 
           p.z < gridResolution.z;
}

// Chunked flattening
uint getGridIndex(uvec3 index, uvec4 gridResolution)
{
    // Extract grid dimensions (ignore w component)
    uvec3 dims = gridResolution.xyz;
    const uint chunkSize = 8u;
    uvec3 chunkPos = index / chunkSize;
    uvec3 localPos = index % chunkSize;
    
    // Calculate chunks per dimension
    uvec3 chunksPerDim = (dims + chunkSize - 1u) / chunkSize;
    
    // Calculate chunk index using row-major ordering
    uint chunkIndex = (chunkPos.z * chunksPerDim.y * chunksPerDim.x) + 
                      (chunkPos.y * chunksPerDim.x) + 
                       chunkPos.x;
    
    // Calculate local index within chunk (row-major ordering)
    uint localIndex = (localPos.z * chunkSize * chunkSize) + 
                      (localPos.y * chunkSize) + 
                       localPos.x;
    
    // Combine chunk index and local index for final flat index
    return (chunkIndex * (chunkSize * chunkSize * chunkSize)) + localIndex;
}

// uint getGridIndex(uvec3 p, uvec4 gridResolution)
// {
//     return p.z * uint(gridResolution.x) * uint(gridResolution.y) +
//            p.y * uint(gridResolution.x) +
//            p.x;
// }

uvec3 unflattenGridIndex(uint index, uvec4 gridResolution)
{
    uint z = index /  (gridResolution.x * gridResolution.y);
    uint y = (index % (gridResolution.x * gridResolution.y)) / gridResolution.x;
    uint x = (index % (gridResolution.x * gridResolution.y)) % gridResolution.x;
    return uvec3(x, y, z);
}

uint worldToGridIndex(vec3 worldPos, uvec4 gridResolution, float cellSize)
{
    vec3 worldSize = vec3(gridResolution.xyz) * cellSize;
    vec3 gridMin = -worldSize * 0.5;
    vec3 gridMax = worldSize * 0.5;
    vec3 normalizedpos = (worldPos - gridMin) / worldSize;  // normalize to [0,1]
    vec3 voxelpos = normalizedpos * vec3(gridResolution.xyz);
    uvec3 mappos = clamp(ivec3(floor(voxelpos)), ivec3(0), ivec3(gridResolution - 1));
	return getGridIndex(mappos, gridResolution);
}

// vec4 gridToWorldPos(uint index) 
// {

// }

uvec3 getRedBlackPosition(uvec3 threadID, uvec4 gridResolution, uint redBlack)
{
    // uint flatIndex = getGridIndex(threadID, uvec4(gridResolution.xy, gridResolution.z / 2, 1.0));
    // // uint flatIndex = getGridIndex(threadID, gridResolution);
    // flatIndex = flatIndex * 2 + redBlack;
    // return unflattenGridIndex(flatIndex, gridResolution);

    // For a checkerboard pattern in 3D, we only need to modify X
    // Y and Z stay the same as the thread ID
    // uint x = threadID.x * 2;  // Double the X position
    uint z = threadID.z * 2;  // Double the X position
    
    // Offset X based on Y and Z parity
    bool shouldOffset = ((threadID.x + threadID.y) % 2) == 0;

    z = z + (shouldOffset ? redBlack : (1 - redBlack));
    
    return uvec3(threadID.x, threadID.y, z);
}

float SOR(float old, float new, uint N)
{
	float alpha = 2.0 / (1.0 + sin(3.14159 / N));
	float result = alpha * new + (1 - alpha) * old;
	return result;
}

vec4 SOR(vec4 old, vec4 new, uint N)
{
	const float alpha = 2.0 / (1.0 + sin(3.14159 / N));
	vec4 result = alpha * new + (1 - alpha) * old;
	return result;
}

